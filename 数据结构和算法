选择排序：两层遍历每次找到最小的一个移到最左边，第二次从第二个开始遍历到最后找到剩下的最小的移到左边   o(n²)
插入排序：两层遍历每次将当前位置的元素和前面已经有序的部分依次比较，如果小就与其交换，，该方法与选择排序的区别就在于找到合适的位置后可以提前结束遍历  o(n~n²)   近乎有序的情况下效率很高
插入排序的优化：先不要贸然与之前的元素每次都交换，可以先判断一下位置，其余元素后移，再放入应该插入的位置（比较规则就是看是否比之前的元素大）

冒泡排序：
第一次外循环

( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 > 1 交换位置
( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 > 4 交换位置
( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 > 2 交换位置
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 < 8 位置不变

第二次外循环（除开最后一个元素8，对剩余的序列）

( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 < 4 位置不变
( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 > 2 交换位置
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 < 5 位置不变

第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1）

( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )

第四次外循环（最后一次）
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )

希尔排序：
先取一个正整数 d1(d1 < n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序
然后取 d2(d2 < d1)
重复上述分组和排序操作；直到取 di = 1(i >= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。
tips:间隔为多少一般就可以分成多少组


归并排序：
// 将arr[l...mid]和arr[mid+1...r]两部分进行归并
	private static void merge(Comparable[] arr, int l, int mid, int r) {

		Comparable[] aux = Arrays.copyOfRange(arr, l, r+1);

		// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1
		int i = l, j = mid+1;
		for( int k = l ; k <= r; k ++ ){

			if( i > mid ){  // 如果左半部分元素已经全部处理完毕
				arr[k] = aux[j-l]; j ++;
			}
			else if( j > r ){   // 如果右半部分元素已经全部处理完毕
				arr[k] = aux[i-l]; i ++;
			}
			else if( aux[i-l].compareTo(aux[j-l]) < 0 ){  // 左半部分所指元素 < 右半部分所指元素
				arr[k] = aux[i-l]; i ++;
			}
			else{  // 左半部分所指元素 >= 右半部分所指元素
				arr[k] = aux[j-l]; j ++;
			}
		}
	}

	// 递归使用归并排序,对arr[l...r]的范围进行排序
	private static void sort(Comparable[] arr, int l, int r) {

		if (l >= r)
			return;

		int mid = (l+r)/2;
		sort(arr, l, mid);
		sort(arr, mid + 1, r);
		merge(arr, l, mid, r);
	}

快速排序：
int partition（int[] r，first，end）{
	i = first;
	j = end;
	while(i<j){
		while(i<j&&r[i]<=r[j]){
			j--;//右侧扫描
		}
		if(i<j){
			swap(r[i],r[j]);
			//交换并准备左侧扫描，将大的移到右边
			i++;
		}
		while(i<j&&r[i]<=r[j]){
			i++;//左侧扫描
		}
		if(i<j){
			swap(r[j],r[i]);
			//交换并准备右侧扫描，将小的移到右边
			j--;
		}
	}
	return i;
}
递归调用：
   position =  partition(arr,first,end);
   sort(r,first,position-1);
   sort(r,position+1,end);