1.详细jvm内存模型
规定了主内存工作内存和线程之间的交互关系，8种操作，volatile和synchronized的一些特殊定义，实现三个特性，原子性，可见性和有序性。

2、讲讲什么情况下回出现内存溢出，内存泄漏？
内存泄漏：对象一直存在到GC Root的引用，导致垃圾收集器一直没办法自动进行垃圾回收
内存溢出：分配的内存不够，内存中的对象没有被回收，且确实有存在的必要，就会导致内存溢出

3、说说Java线程栈？
线程栈是指某时刻时内存中线程调度的栈信息，当前调用的方法总是位于栈顶，线程栈的内容是随着线程的运行状态变化而变化的，线程中新建立的线程也将拥有自己的线程栈B，两者交替执行，不同于方法调用栈

4、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？
规则：1.对象优先在新生代eden分配
	 2.大对象直接直接进入老年代 pretenuresizethreshold参数设置大对象大小的阈值
	 3.长期存活的对象将进入老年代
	 判断条件：在年轻代的对象经过第一次年轻代GC后仍然存活，并且能够被survivor容纳的话就移到survivor区中，并且年龄+1，每熬过一次就+1，当年龄增长到一定大小（默认15，可以通过maxtenuringthredshold参数设置）就晋升到老年代，并且如果survivor空间中相同年龄的所有对象大小综合大于该空间的一半，则该区域大于等于该年龄的对象可以直接进入老年代而无须等到设置的年龄大小

5、JVM 出现 fullGC（老年代GC） 很频繁，怎么去线上排查问题？
Full GC的原因
我们知道Full GC的触发条件大致情况有以下几种情况：
1.程序执行了System.gc() //建议jvm执行fullgc，并不一定会执行
2.执行了jmap -histo:live pid命令 //这个会立即触发fullgc
3.在执行minor gc的时候进行的一系列检查
执行Minor GC的时候，JVM会检查老年代中最大连续可用空间是否大于了当前新生代所有对象的总大小。
如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。如果小于了，JVM会检查是否开启了空间分配担保机制，如果没有开启则直接改为执行Full GC。
如果开启了，则JVM会检查老年代中最大连续可用空间是否大于了历次晋升到老年代中的平均大小，如果小于则执行改为执行Full GC。如果大于则会执行Minor GC，如果Minor GC执行失败则会执行Full GC
4.使用了大对象 //大对象会直接进入老年代
5.在程序中长期持有了对象的引用 //对象年龄达到指定阈值也会进入老年代
使用jvisualVM工具查看那个占用内存比较多，定位到相应代码的位置

6、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？
防止恶意加载别的类
双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。
无法通过强制加载自定义的类加载器绕过双亲委派模型，因为在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。
加载流程图:http://upload-images.jianshu.io/upload_images/2154124-d5859f8e79069128?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
换句话说，如果自定义类加载器，就必须重写findClass方法！
defineClass主要的功能是：将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组
打破模型：（1）重写loadclass方法兼容双亲委派模型以前的一些用户自定义的类
		 (2)父类调用子类  父类不认识子类的类加载器  JSNI 通过上下文类加载器实现
		 （3）实现热部署热替换  OSGI 每个模块都有自己的类加载器，替换模块时连同类加载器一起替换


7、类的实例化顺序？
（静态变量、静态初始化块）——>（变量、初始化块）——>构造器。
//一般类
    public static class General {
        // 静态变量
        public static String staticField = "静态变量";
        // 变量
        public String field = "变量";

        // 静态初始化块
        static {
            System.out.println(staticField);
            System.out.println("静态初始化块");
        }

        // 初始化块
        {
            System.out.println(field);
            System.out.println("初始化块");
        }

        // 构造器
        public General() {
            System.out.println("构造器");
        }

    }
有父类的话，在满足上述顺序的情况下优先初始化对应的变量的父类的变量（括号里面的部分的初始化捆绑完成）
父类--静态变量
父类--静态初始化块
子类--静态变量
子类--静态初始化块
父类--变量
父类--初始化块
父类--构造器
子类--变量
子类--初始化块
子类--构造器

8.JVM垃圾回收机制，何时触发MinorGC等操作？
Minor GC触发条件：当Eden区满时，触发Minor GC。
Full GC触发条件：
（1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）方法去空间不足
*（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存（Minor GC之前会先检查老年代的分配担保机制是否满足，担保风险在于取以前晋升到老年代的对象大小的平均值）
（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

引用计数算法维护一个计数值，值为0时回收对象 这种算法不适用于循环引用的状况
可达性分析算法：以GC Roots对象（一般为虚拟机栈中的本地变量、方法区中的静态变量、方法区中常量引用的对象、本地方法栈中的native方法引用的对象）为起点向下搜索，当没有路径可以到达该对象时就判断为可回收的对象（但是最终的回收却要经过两次标记）


10、各种回收器，各自优缺点，重点CMS、G1？
Serial：单线程  新生代 stop the world 单线程效率最高
ParNew：Serial多线程版本  新生代 与用户线程并发工作 
Parallel Scavenge：关注吞吐量
Serial Old: Serial的老年代版本
Parallel Old: Parallel的老年代版本
CMS：concurrent mark sweep并发标记清除
	初始标记：标记GC Root能关联到的对象
	并发标记：进行GC Root追踪
	重新标记：修正并发标记期间的用户程序继续运作产生的变动记录
	并发清除
	缺点：并发清理期间的浮动垃圾  标记清除算法产生的空间碎片
G1：并行与并发，分代收集（根据对象年龄），空间整合，可预测的停顿，可指定允许的最大停顿时间，并且建立回收优先级列表在设置的回收时间下优先回收最有价值的内存空间，采用的是标记整理的算法不会产生空间碎片
	初始标记
	并发标记
	最终标记
	筛选回收
	缺点：会产生浮动垃圾


11、各种回收算法
标记清除
复制（将内存空间分为8：1：1的eden和survivor，每次将8的eden和1的survivor复制到另一个survivor中，容纳不下时进行分配担保进入老年代）
标记整理
分代收集（新生代存活率低采用复制，老年代存活率高复制代价高昂采用标记清除或者标记整理）











